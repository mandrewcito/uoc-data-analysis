---
title: 'Tipología y ciclo de vida de los datos: Práctica 2'
author: "Autor: Nombre estudiante"
date: '`r format(Sys.Date(),"%e de %B %Y")`'
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
    includes:
      in_header: PRA2-header.html
  pdf_document:
    highlight: zenburn
    toc: yes
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
# https://cran.r-project.org/web/packages/ggplot2/index.html
if (!require('ggplot2')) install.packages('ggplot2'); library('ggplot2')
# https://cran.r-project.org/web/packages/dplyr/index.html
if (!require('dplyr')) install.packages('dplyr'); library('dplyr')
library(plotly)
library(nortest)
library(graphics)
library(prediction)
library(MVN)
```


# Descripción del dataset

El conjunto de datos del titanic es ampliamente concido en la comunidad del ML. Es más, forma parte de los retos de iniciación en la plataforma [kaggle](https://www.kaggle.com/c/titanic/overview).

Este conjunto de datos, es la representación de las personas que embarcaron en el titanic. En el, se recogen multitud de datos sobre cada persona, relativos a su edad, pais y clase en la que embarcaron, además de si sobrevivieron o no.


## ¿Por qué es importante?

Este cojunto de datos tiene la posibilidad de explicar algunos datos de la catastrofe. Puede aclarar si hubo algún condicionante para la muerte o supervivencia de las personas más allá del puro azar.

## ¿Qué pregunta pretende responder?

Este cojunto de datos pretende elaborar un modelo predictivo y con el responder a la pregunta: ¿Qué tipo de personas tenían más probabilidades de sobrevivir?

# Integración de los datos de interés a analizar

Antes de integrar, vamos a describir las variables que caracterízan a estos datos:

* **PassengerId** Id del pasajero

* **Name** Nombre del pasajero en formato cadena.

* **Sex** Factor con los niveles male/female.

* **Age** Valor numérico con la edad.

* **Pclass** Factor con la clase del ticket(1 = 1st, 2 = 2nd, 3 = 3rd)

* **Embarked** Factor con el embarque de la persona(C = Cherbourg, Q = Queenstown, S = Southampton).

* **Cabin** camarote

* **Fare** Valor numérico con el precio del ticket (NA  para miembros de la tripulación musicos y empleados de la compañia).

* **SibSp** Número de conyuges a bordo.

* **Parch** Número de padres, hijos a bordo.

* **Survived** Factor con dos niveles indicando si sobrevivió o no(0 = No, 1 = Yes).

Escogemos las columnas que serán factores:
```{r}
factors = c("Sex"="factor","Pclass"="factor","Cabin"="factor", "Embarked"="factor","Survived"="factor");
```

Cargamos los datos:

```{r}
titanicData <- read.csv('titanic.csv', stringsAsFactors = FALSE, colClasses = factors );
```

```{r}
summary(titanicData);
```
Los datos de interés de ese cojunto de datos serán los que nos aporten algo de información sobre las personas pero a nivel de cojunto, es decir datos como nombre, identificador de pasajero o número de ticket no nos resultan de utilidad. Por lo que podemos crear un conjunto de datos solamente con los datos adecuados:


```{r}
cols_remove <- c("PassengerId", "Name", "Ticket")
titanicData <- titanicData[, !(colnames(titanicData) %in% cols_remove)]
summary(titanicData);
```
# Limpieza de los datos.

## ¿Los datos contienen ceros o elementos vacíos? ¿Cómo gestionarías cada uno de estos casos?

Para comprobar si los datos contienen elementos vacíos se ejecuta la siguiente sentencia.

```{r}
colSums(is.na(titanicData))
```

Se puede observar que la columna Age contiene 177 valores nulos. Existen diferentes políticas para el tratamiento de los valores nulos:

* **Eliminarlos**: En Ocasiones, compensa eliminar estas filas, ya que pueden generar distorsiones a la hora de hacer cálculos con las columnas que contienen los valores nulos.

* **Reemplazo**: Se podrían reemplazar los valores por la media, la mediana o la moda. Estas medidas se pueden intentar particular en función de otras columnas para que no siempre sean los mismos para todas las entradas nulas.

* **Asignación de una categoría**: Si se discretizan los datos en, por ejemplo, rangos de edad, se puede particularizar todos los valores nulos en una categoría especial llamada "edad desconocida".

* **Predicción de los valores nulos**: Por último, se pueden inferir los valores mediante predicciones.

En este caso, se van a inferir los valores en función de otros parámentros. Para hacer esto, partimos de que es muy probable que la edad media de las personas que viajan en Pclass3 es diferente a la edad media de las personas que viajan en Pclass1. Además, esa edad será diferente en función de si estamos ante un hombre o una mujer. Por tanto, para inferir los valores de edad perdidos, se agrupa por Sex y Pclass, para posteriormente calcular las medianas de cada serie agrupada.

Primero, se calcula la media y la mediana de edad en función de la clase y el género del pasajero. 
```{r, warning= FALSE, message = FALSE}
by_sex_class <- titanicData %>% group_by(Sex, Pclass)  %>% summarise(mean = mean(Age, na.rm = TRUE), median = median(Age, na.rm = TRUE))
                      
by_sex_class


```

Se observa que la media y la mediana de edad varía en función del género y la clase en la que viajaban. Se procede a rellenar los valores nulos en la columna de edad por los valores de mediana en función de Sex y Pclass.  

```{r}
titanicData$Age[titanicData$Sex == "female" & titanicData$Pclass == "1" & is.na(titanicData$Age)] <- by_sex_class$median[by_sex_class$Sex == "female" & by_sex_class$Pclass == "1"]

titanicData$Age[titanicData$Sex == "female" & titanicData$Pclass == "2" & is.na(titanicData$Age)] <- by_sex_class$median[by_sex_class$Sex == "female" & by_sex_class$Pclass == "2"]

titanicData$Age[titanicData$Sex == "female" & titanicData$Pclass == "3" & is.na(titanicData$Age)] <- by_sex_class$median[by_sex_class$Sex == "female" & by_sex_class$Pclass == "3"]

titanicData$Age[titanicData$Sex == "male" & titanicData$Pclass == "1" & is.na(titanicData$Age)] <- by_sex_class$median[by_sex_class$Sex == "male" & by_sex_class$Pclass == "1"]

titanicData$Age[titanicData$Sex == "male" & titanicData$Pclass == "2" & is.na(titanicData$Age)] <- by_sex_class$median[by_sex_class$Sex == "male" & by_sex_class$Pclass == "2"]

titanicData$Age[titanicData$Sex == "male" & titanicData$Pclass == "3" & is.na(titanicData$Age)] <- by_sex_class$median[by_sex_class$Sex == "male" & by_sex_class$Pclass == "3"]

```

Se vuelve a comprobar si existen valores nulos.

```{r}
colSums(is.na(titanicData))
```

Se han eliminado los valores nulos. Ahora, se comprueba que el summary no difiere mucho del original.

```{r}
summary(titanicData)
```

La media de edad ha bajado ligeramente, pero en general los datos se mantienen estables aún habiendo inferido 177 entradas.

En el summary se pueden observar diferentes columnas con datos anómalos o vacíos. Se procede a analizar uno a uno cada caso.

La columna SibSp contiene muchos valores a 0. En esta columna este valor es perfectamente normal, ya que indica el número de hermanos o esposas a bordo del barco para cada persona.

La columna Parch también contienen valores a 0, pero también cuadra, ya que este campo indica el núero de padres o hijos a bordo.

La columna Fare indica el precio que el pasajero pagó para estar en el barco. El mínimno de esta columna es 0, lo cual no tendría demasiado sentido. Se procede a mirar cuántas entradas tienen 0 en el precio.

```{r}
filter(titanicData, Fare == 0)
```

Es destacable que todas aquellas entradas que tienen Fare = 0 son de hombres. Dado que no han pagado nada, estas personas podrían ser tripulación del barco, por lo que se mantienen estas entradas.

La columna Cabin contiene muchísimos valores nulos, y no se puede inferir de ninguna manera. Tampoco parece que aporte demasiada información útil, por lo que se desecha.

```{r}
titanicData <- subset(titanicData, select = -c(Cabin))
```

Por último, la columna Embarked contiene dos valores nulos que sí serían interesantes de completar. En este caso, para evitar tener 4 categorías y que se distorsionen un poco esos datos, se imputan estos dos valores con la moda, es decir, con el valor "S".

```{r}
titanicData$Embarked[titanicData$Embarked == ""] <- "S"

# Se elimina la clase sobrante.

titanicData$Embarked <- as.factor(as.character(titanicData$Embarked))

```

Se hace un último summary para comprobar que todo ha quedado correctamente.

```{r}
summary(titanicData)
```


## Identificación y tratamiento de valores extremos.

La mejor manera de tratar los valores extremos es ir mostrando los diferentes valores de columnas numéricas en un diagrama de cajas y bigotes o *boxplot*. Para la realización de estos diagramas se ha utilizado la librería Plotly.

```{r, message = FALSE, warning= FALSE}
fig <- plot_ly(y = titanicData$Age, type = "box", name = "Edad")

fig
```

Aunque vemos unos cuantos outliers en el campo Edad, son perfectamente normales.

Veamos la columna Fare.

```{r}
fig <- plot_ly(y = titanicData$Fare, type = "box", name = "Precio del Ticket")

fig
```

Se observan bastantes outliers, pero hay un precio que destaca más que los demás. Vamos a analizar esas filas.

```{r}
filter(titanicData, Fare > 500)

```

Las tres filas pertenecen a personas del mismo rango de edad que embarcaron desde el mismo puerto. Por la exactitud de los datos y su homogeneidad, parecen datos correctos, por lo que se mantienen en el dataset.


# Análisis de los datos

En esta sección dividiremos el conjunto de datos en subconjuntos para analizar y compararlos entre ellos.

## Selección de grupos de datos a analizar/comparar

El conjunto de datos lo analizaremos en fución a los siguientes grupos para determinar si guardan relación con la supervivencia:

* **Rango de edad** Columna AgeGroup
* **Poder adquisitivo** Columna Pclass nos dice en que clase embarcaron, lo que nos ayuda a inferir su nivel adquisitivo.
* **Sexo** Columna Sex.

Crearemos una columna en base a la edad, diviendola en segmentos para así poder realizar un análisis por categorías:

```{r}
titanicData$AgeGroup <- cut(titanicData$Age, breaks = c(0,10,20,30,40,50,60,70,100), labels = c("0-9", "10-19", "20-29", "30-39","40-49","50-59","60-69","70-79"))
plot(titanicData$AgeGroup)
```


```{r}

# Por poder adquisitivo
titanicData.firstClass <- titanicData[titanicData$Pclass == "1",]
titanicData.firstClass <- titanicData[titanicData$Pclass == "2",]
titanicData.firstClass <- titanicData[titanicData$Pclass == "3",]

# Por sexo
titanicData.female <- titanicData[titanicData$Sex == "female",]
titanicData.male <- titanicData[titanicData$Sex == "male",]
```

Vamos a mostrar con gráficas cada uno de los grupos nombrados junto con la supervivencia.

### Rango de edad

```{r}
ggplot(data=titanicData[1:nrow(titanicData),],aes(x=AgeGroup,fill=Survived))+geom_bar()
```
```{r, warning=FALSE}
ggplot(data = titanicData,aes(x=Age,fill=Survived))+geom_histogram(binwidth = 3,position="fill")+ylab("Frequencia")
```
Con este último gráfico, podemos deducir que los niños tuvieron más posibilidades de salvarse y los mayores de 60 muchas menos.

### Nivel adquisitivo

```{r}
ggplot(data=titanicData[1:nrow(titanicData),],aes(x=Pclass,fill=Survived))+geom_bar()
```
También se aprecia un aumento de la supervivencia en las clases 1 y 2 con respecto a la 3.

### Sexo

```{r}
ggplot(data=titanicData[1:nrow(titanicData),],aes(x=Sex,fill=Survived))+geom_bar()
```

## Comprobación de normalidad y homogeneidad de la varianza.

## Comprobación de normalidad y homogeneidad de la varianza.

```{r}
summary(titanicData)
```


### Comprobación de normalidad

Se procede a comprobar la normalidad de las variables numéricas, es decir, Age, SibSp, Parch, y Fare. Para ello, se crearán histogramas univariados y QQ-plots, que permiten a los analistas de datos identificar datos sesgados hacia los lados y ver la normalidad de las variables. Se utiliza la librería MVN. El test aplicado es el Royston, 

```{r}
titanicData_numeric<- titanicData %>% select_if(is.numeric)

result<- mvn(data=titanicData_numeric, mvnTest="royston", univariatePlot="histogram")
```

En los histogramas se observa claramente que las variables SibSp, Parch y Fare están sesgadas hacia la izquierda y no siguen una distribución normal. 

Sin embargo, la variable Age sí sigue aproximadamente una distribución Normal. Se procede a representar los QQ-Plots para corroborar esta suposición.

```{r}
result<-mvn(data=titanicData_numeric, mvnTest = "royston", univariatePlot = "qqplot")
```

De nuevo, se observa que Age sí sigue aproximadamente una distribución normal. 

Para contrastar la normalidad de esta variable, se aplica también el Test Shapiro-Wilk. Este test toma las siguientes hipótesis:

* **Hipótesis nula**: Los datos de la muestra no son significativamente diferentes de una población normal.
* **Hipótesis alternativa**: Los datos de la muestra son significativamente diferentes de una población normal.

Para todo valor de probabilidad mayor que el nivel de significación, en este caso 0.05, se acepta la hipótesis nula y se rechaza la alternativa.

```{r}
shapiro.test(titanicData$Age)
```

Dado que el p-valor es menor que 0.05, se rechaza la hipótesis nula, por lo que la varaible Age no sigue una distribución normal.

Se realiza el mismo test para las otras 3 variables, con idéntico resultado.

```{r}
shapiro.test(titanicData$SibSp)
```

```{r}
shapiro.test(titanicData$Parch)
```


```{r}
shapiro.test(titanicData$Fare)
```

### Homogeneidad de la varianza.

Pasamos a estudiar la homogenidad de la varianza mediante la aplicación del test de *Fligner-Killeen*. Ya que es una alternativa cuando no se cumple la normalidad de las muestras

```{r}
fligner.test(as.integer(titanicData$Sex), as.integer(titanicData$Survived))
```

```{r}
fligner.test(as.integer(titanicData$Pclass), as.integer(titanicData$Survived))
```

Debido a que 3 de las 4 variables no siguen una distribución normal, se debe utilizar un test que permita obtener la homogeneidad en variables no normales. Por eso, hemos decidido utilizar en test Fligner-Killeen, un test no paramétrico que compara las varianzas basándose en la mediana.

Este test toma como premisas las siguientes hipótesis:

* **Hipótesis nula**: Todas las varianzas de las poblaciones son iguales.
* **Hipótesis alternativa**: Al menos dos de ellas difieren.

Primero, se aplica el test a todas las variables a la vez.

```{r}
fligner.test(x = titanicData_numeric)
```

Dado que el p-valor es inferior a 0.05, concluimos que tomando todas las variables al mismo tiempo no todas las varianzas son homogéneas. Se procede ahora a comprobar las variables 2 a 2.

#### Homogeneidad de varianza entre Age y Survived.

Se mirará la homogeneidad de la varianza de la variable Age en función de la Supervivencia. Primero, se representa ambas varianzas en un boxplot para hacernos una idea de si podría existir homogeneidad.

```{r}
boxplot(Age ~ Survived, data = titanicData)
```

Parece que podría cumplirse la homogeneidad. Se procede a ejecutar el test.

```{r}
fligner.test(Age ~ Survived, data = titanicData)
```

## Aplicación de pruebas estadísticas

### Correlaciones 

¿ Qué variables influyen en la supervivencia? En este apartado comprobaremos las correlaciones entre distintas variables y su influencia en la supervivencia.

```{r}
corr_matrix <- matrix(nc = 2, nr = 0)
colnames(corr_matrix) <- c("estimate", "p-value")

# con respecto al campo "survive"
for (i in c("Age", "Sex","Pclass")) {
    spearman_test = cor.test(
        as.double(titanicData[,i]),
        as.integer(titanicData$Survived),
        method = "spearman", exact = FALSE)
    
  corr_coef = spearman_test$estimate
  p_val = spearman_test$p.value
  
    pair = matrix(ncol = 2, nrow = 1)
    pair[1][1] = corr_coef
    pair[2][1] = p_val
    corr_matrix <- rbind(corr_matrix, pair)
  rownames(corr_matrix)[nrow(corr_matrix)] <- i
} 
print(corr_matrix)
```

La menos correlacionada quizá sería la edad y la más fuertemente correlacionada la edad.

### Contraste de hipótesis: 

#### Dependencia entre Pclass y Survived

En primer lugar, se comprobará si las diferentes clases en las que viajaban los pasajeros influyó en si sobrevivieron al accidente o no. Por tanto, se identifican las siguientes hipótesis:

* Hipótesis nula: El factor PClass y el el factor Survived son independientes.
* Hipótesis alternativa: Los dos factores son dependientes.

Para comprobar la dependencia entre dos variables categóricas, se aplica el test chi-cuadrado. Primero, se genera una tabla de contingencia entre ambos factores.


```{r}
contingece <- table(titanicData$Survived, titanicData$Pclass)
contingece
```

Una vez creada la tabla, se aplica el test.

```{r}
chisq.test(contingece)
```

Dado que el p-valor es inferior a 0.05, se rechaza la hipótesis nula, y aceptamos la hipótesis alternativa.

Es decir, el test determina que la clase de los pasajeros es determinante a la hora de predecir si sobrevivió o no.

#### Dependencia entre AgeGroup y Survived

A continuación, se comprobará si la edad de los pasajeros influyó en si sobrevivieron al accidente o no. Por tanto, se identifican las siguientes hipótesis:

* Hipótesis nula: El factor Age y el el factor Survived son independientes.
* Hipótesis alternativa: Los dos factores son dependientes.

Para comprobar la dependencia entre dos variables categóricas, se aplica el test chi-cuadrado. Primero, se genera una tabla de contingencia entre ambos factores. Se utilizará los grupos de edad.


```{r}
contingece <- table(titanicData$Survived, titanicData$AgeGroup)
contingece
```

Una vez creada la tabla, se aplica el test.

```{r}
chisq.test(contingece)
```

Dado que el p-valor es inferior a 0.05, se rechaza la hipótesis nula, y aceptamos la hipótesis alternativa.

Es decir, el test determina que la edad de los pasajeros es determinante a la hora de predecir si sobrevivió o no.

#### Dependencia entre Sex y Survived

A continuación, se comprobará si el sexo de los pasajeros influyó en si sobrevivieron al accidente o no. Por tanto, se identifican las siguientes hipótesis:

* Hipótesis nula: El factor Sex y el el factor Survived son independientes.
* Hipótesis alternativa: Los dos factores son dependientes.

Para comprobar la dependencia entre dos variables categóricas, se aplica el test chi-cuadrado. Primero, se genera una tabla de contingencia entre ambos factores. Se utilizará los grupos de edad.


```{r}
contingece <- table(titanicData$Survived, titanicData$Sex)
contingece
```

Una vez creada la tabla, se aplica el test.

```{r}
chisq.test(contingece)
```

Dado que el p-valor es inferior a 0.05, se rechaza la hipótesis nula, y aceptamos la hipótesis alternativa.

Es decir, el test determina que el sexo de los pasajeros es determinante a la hora de predecir si sobrevivió o no.

### Regresión logística:

```{r}
model <- glm(formula = as.factor(Survived) ~ Sex , family = "binomial", data= titanicData);
summary(model)
```

```{r}
model <- glm(formula = as.factor(Survived) ~ Sex + Age , family = "binomial", data= titanicData);
summary(model)
```

```{r}
model <- glm(formula = as.factor(Survived) ~ Sex + Age + Pclass, family = "binomial", data= titanicData);
summary(model)
```

# Representación de los resultados

# Resolución del problema

## Conclusiones

